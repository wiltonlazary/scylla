--
-- basic: ensure the grammar works
--
create table lwt (a int primary key, b int);
{
	"status" : "ok"
}
-- insert if not exists
insert into lwt (a, b) values (1, 1) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
-- delete if exists
delete from lwt where a=1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : null
}
-- update with condition
update lwt set b = 2 where a=1 if b = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : null
}
-- update if exists
update lwt set b = 2 where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : null
}
-- update if exists with a scan: proper error message
update lwt set b = 2 where b = 1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING)",
	"status" : "error"
}
select * from lwt allow filtering;
{
	"rows" : null
}
-- incorrect syntax: update if *not* exists
update lwt set b=3 where a=2 if not exists;
{
	"message" : "exceptions::syntax_exception (line 1:32 no viable alternative at input 'not')",
	"status" : "error"
}
-- incorrect syntax: delete if *not* exists
delete from lwt where a=2 if not exists;
{
	"message" : "exceptions::syntax_exception (line 1:29 no viable alternative at input 'not')",
	"status" : "error"
}
--
-- timestamp: using timestamp clause is not allowed
--
-- check that using timestamp without LWT clause works
insert into lwt (a, b) values (1, 1) using timestamp 1;
{
	"status" : "ok"
}
-- with LWT, it's not allowed
insert into lwt (a, b) values (1, 1) if not exists using timestamp 1;
{
	"message" : "exceptions::invalid_request_exception (Cannot provide custom timestamp for conditional updates)",
	"status" : "error"
}
--
--
-- update if not exists is not allowed (grammar error), it doesn't make sense
update lwt set b = 2 where a = 1 if not exists;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input 'not')",
	"status" : "error"
}
-- update with multiple partitions can not have conditions
-- Cassandra output: code=2200 [Invalid query] message="IN on the partition
-- key is not supported with conditional updates"
update lwt set b = 2 where a in (1, 2) if b = 1;
{
	"message" : "exceptions::invalid_request_exception (IN on the partition key is not supported with conditional updates)",
	"status" : "error"
}

drop table lwt;
{
	"status" : "ok"
}
--
-- basic: ends
--
--
-- clustering: tests related to lwt and clustering keys
--
-- create a table with a partitioning key and a clustering key
create table lwt (a int, b int, c int, primary key (a,b));
{
	"status" : "ok"
}
-- update with multiple clustering keys can not have conditions
-- Cassandra output: code=2200 [Invalid query] message="IN on the clustering
-- key is not supported with conditional updates"
update lwt set c = 2 where a = 1 and b in (2,3)  if c = 1;
{
	"message" : "exceptions::invalid_request_exception (IN on the clustering key columns is not supported with conditional updates)",
	"status" : "error"
}
-- update with a clustering key - should work
update lwt set c = 2 where a = 1 and b = 2  if c = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
-- update with a single clustering key inside IN predicate
-- correctly identified as a single-key update
update lwt set c = 2 where a = 1 and b in (2) if c = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
-- unrestricted conditional update,
-- Casssandra: code=2200 [Invalid query]
-- message="Some clustering keys are missing: b"
update lwt set c=3 where a=1 if c=2;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part b)",
	"status" : "error"
}
--  comparing columns
update lwt set c=3 where a=1 if c=a;
{
	"message" : "exceptions::syntax_exception (line 1:35 no viable alternative at input ';')",
	"status" : "error"
}
-- cleanup
drop table lwt;
{
	"status" : "ok"
}
--
-- clustering: ends
--
-- limitations: check grammar/feature limitations of LWT
--
create table lwt (a int, b frozen<map<int, int>>, c int, primary key (a, b));
{
	"status" : "ok"
}
insert into lwt (a, b, c) values (1, {1:1, 2:2}, 3);
{
	"status" : "ok"
}
-- Strictcly speaking this is not an LWT check, but we need to ensure that
-- LWT restrictions are a superposition of modification statement
-- restrictions
update lwt set c=3 where a=1 and b contains 1 if c=1;
{
	"message" : "exceptions::invalid_request_exception (Cannot restrict clustering columns by a CONTAINS relation without a secondary index or filtering)",
	"status" : "error"
}

drop table lwt;
{
	"status" : "ok"
}

-- conditional updates and counters: not supported
create table lwt (a int primary key, b counter);
{
	"status" : "ok"
}
update lwt set  b = b+1 where a = 1;
{
	"status" : "ok"
}
update lwt set  b = b+1 where a = 1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Conditional updates are not supported on counter tables)",
	"status" : "error"
}
insert into lwt (a, b) values (1,1) if not exists;
{
	"message" : "exceptions::invalid_request_exception (INSERT statement are not allowed on counter tables, use UPDATE instead)",
	"status" : "error"
}
delete from lwt where a=1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Conditional updates are not supported on counter tables)",
	"status" : "error"
}
delete from lwt where a=1 if b=2;
{
	"message" : "exceptions::invalid_request_exception (Conditional updates are not supported on counter tables)",
	"status" : "error"
}
drop table lwt;
{
	"status" : "ok"
}
--
-- limitations: ends
--
---
-- if_exists: check if exists/if not exists works
---
create table lwt (a int primary key, b int);
{
	"status" : "ok"
}
-- insert if not exists
insert into lwt (a, b) values (1, 1) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
-- should not update
insert into lwt (a, b) values (1, 2) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
-- should update
insert into lwt (a, b) values (2, 2) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		},
		{
			"a" : "2",
			"b" : "2"
		}
	]
}
-- should delete
delete from lwt where a=2 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "2",
			"b" : "2"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
-- should not update
update lwt set b=3 where a=2 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
-- should update
update lwt set b=3 where a=1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "3"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
--
-- if_exists: ends end of check for if-exists/if-not-exists
--
-- conditional updates and static columns
-- see also https://issues.apache.org/jira/browse/CASSANDRA-10532
create table lwt (id bigint, uuid uuid, stc text static, value text, primary key(id, uuid));
{
	"status" : "ok"
}
delete stc FROM lwt WHERE id=1 IF stc='key';
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}

create table lwt (p int, c int, s int static, v int, primary key(p, c));
{
	"status" : "ok"
}
insert into lwt(p, c, v) values(1, 1, 1);
{
	"status" : "ok"
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"v" : "1"
		}
	]
}
-- must fail: regular row conditions do not match
insert into lwt(p, c, v) values(1, 1, 10) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "1",
			"p" : "1",
			"v" : "1"
		}
	]
}
insert into lwt(p, c, s) values(1, 1, 10) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "1",
			"p" : "1",
			"v" : "1"
		}
	]
}
update lwt set v=10 where p=1 and c=1 if v=2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"v" : "1"
		}
	]
}
delete from lwt where p=1 and c=1 if v=2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"v" : "1"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"v" : "1"
		}
	]
}
-- must succeed: regular row conditions match
insert into lwt(p, c, v) values(1, 2, 2) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set v=10 where p=1 and c=1 if v=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"v" : "1"
		}
	]
}
update lwt set v=20 where p=1 and c=2 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "2",
			"p" : "1",
			"v" : "2"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"v" : "10"
		},
		{
			"c" : "2",
			"p" : "1",
			"v" : "20"
		}
	]
}
-- must fail: there is no static row in the partition
update lwt set s=2 where p=1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "1",
			"p" : "1",
			"v" : "10"
		}
	]
}
update lwt set s=2 where p=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set v=2 where p=1 and c=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
delete s from lwt where p=1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "1",
			"p" : "1",
			"v" : "10"
		}
	]
}
delete s from lwt where p=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
delete v from lwt where p=1 and c=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
delete s from lwt where p=1 and c=1 if s=1 and v=10;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"v" : "10"
		}
	]
}
delete v from lwt where p=1 and c=1 if s=1 and v=10;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"v" : "10"
		}
	]
}
delete from lwt where p=1 and c=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
delete from lwt where p=1 and c=1 if s=1 and v=10;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"v" : "10"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"v" : "10"
		},
		{
			"c" : "2",
			"p" : "1",
			"v" : "20"
		}
	]
}
-- must succeed: there is no static row in the partition (even though there are regular rows)
insert into lwt(p, s) values(1, 1) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "1",
			"p" : "1",
			"v" : "10"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"s" : "1",
			"v" : "10"
		},
		{
			"c" : "2",
			"p" : "1",
			"s" : "1",
			"v" : "20"
		}
	]
}
-- must fail: static row conditions do not match
insert into lwt(p, s) values(1, 2) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "1",
			"p" : "1",
			"s" : "1",
			"v" : "10"
		}
	]
}
update lwt set s=3 where p=1 if s=2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
update lwt set v=3 where p=1 and c=1 if s=2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
delete s from lwt where p=1 if s=2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
delete v from lwt where p=1 and c=1 if s=2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
delete s from lwt where p=1 and c=1 if s=2 and v=10;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1",
			"v" : "10"
		}
	]
}
delete v from lwt where p=1 and c=1 if s=2 and v=10;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1",
			"v" : "10"
		}
	]
}
delete from lwt where p=1 and c=1 if s=2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
delete from lwt where p=1 and c=1 if s=2 and v=10;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1",
			"v" : "10"
		}
	]
}
-- must succeed: regular row conditions match
delete from lwt where p=1 and c=1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "1",
			"p" : "1",
			"s" : "1",
			"v" : "10"
		}
	]
}
delete from lwt where p=1 and c=2 if v=20;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"v" : "20"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"p" : "1",
			"s" : "1"
		}
	]
}
-- must succeed: there is no regular rows in the partition (even though there is a static row)
insert into lwt(p, c, v) values(1, 1, 1) if not exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"s" : "1",
			"v" : "1"
		}
	]
}
delete from lwt where p=1 and c=1;
{
	"status" : "ok"
}
select * from lwt;
{
	"rows" : 
	[
		{
			"p" : "1",
			"s" : "1"
		}
	]
}
-- must fail: there is no regular rows in the partition
update lwt set v=10 where p=1 and c=1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set v=10 where p=1 and c=1 if s=1 and v=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
update lwt set s=10 where p=1 and c=1 if s=1 and v=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
delete s from lwt where p=1 and c=1 if s=1 and v=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
delete v from lwt where p=1 and c=1 if s=1 and v=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
delete from lwt where p=1 and c=1 if s=1 and v=1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "1"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"p" : "1",
			"s" : "1"
		}
	]
}
-- must succeed: the condition applies only to the static row
delete from lwt where p=1 and c=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1"
		}
	]
}
delete v from lwt where p=1 and c=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1"
		}
	]
}
update lwt set v=10 where p=1 and c=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1"
		}
	]
}
update lwt set s=10 where p=1 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"s" : "10",
			"v" : "10"
		}
	]
}
insert into lwt(p, c, s, v) values(2, 2, 20, 20);
{
	"status" : "ok"
}
insert into lwt(p, s) values(3, 30);
{
	"status" : "ok"
}
insert into lwt(p, s) values(4, 40);
{
	"status" : "ok"
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"s" : "10",
			"v" : "10"
		},
		{
			"c" : "2",
			"p" : "2",
			"s" : "20",
			"v" : "20"
		},
		{
			"p" : "4",
			"s" : "40"
		},
		{
			"p" : "3",
			"s" : "30"
		}
	]
}
-- must succeed: static row conditions match
delete s from lwt where p=1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "1",
			"p" : "1",
			"s" : "10",
			"v" : "10"
		}
	]
}
delete s from lwt where p=2 if s=20;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "20"
		}
	]
}
delete s from lwt where p=3 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"p" : "3",
			"s" : "30"
		}
	]
}
delete s from lwt where p=4 if s=40;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "40"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"v" : "10"
		},
		{
			"c" : "2",
			"p" : "2",
			"v" : "20"
		}
	]
}
insert into lwt(p, c, v) values(1, 1, 1);
{
	"status" : "ok"
}
insert into lwt(p, c, v, s) values(1, 2, 2, 1);
{
	"status" : "ok"
}
insert into lwt(p, c, v) values(2, 1, 1);
{
	"status" : "ok"
}
insert into lwt(p, c, v) values(2, 2, 2);
{
	"status" : "ok"
}
insert into lwt(p, c, v, s) values(2, 3, 3, 1);
{
	"status" : "ok"
}
-- must succeed: both static and regular row conditions match
delete v from lwt where p=1 and c=1 if v=1 and s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1",
			"v" : "1"
		}
	]
}
delete s from lwt where p=1 and c=2 if v=2 and s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1",
			"v" : "2"
		}
	]
}
delete from lwt where p=2 and c=3 if v=3 and s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1",
			"v" : "3"
		}
	]
}
update lwt set v=2 where p=2 and c=1 if v=1 and s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1",
			"v" : "1"
		}
	]
}
update lwt set s=2 where p=2 and c=2 if v=2 and s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1",
			"v" : "2"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1"
		},
		{
			"c" : "2",
			"p" : "1",
			"v" : "2"
		},
		{
			"c" : "1",
			"p" : "2",
			"s" : "2",
			"v" : "2"
		},
		{
			"c" : "2",
			"p" : "2",
			"s" : "2",
			"v" : "2"
		}
	]
}
-- sanity checks
update lwt set v=1 where p=1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
update lwt set v=1 where p=1 if s=1;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
update lwt set v=1 where p=1 if v=1;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
update lwt set v=1 where p=1 if s=1 and v=1;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
update lwt set s=1 where p=1 if v=1;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
update lwt set s=1 where p=1 if v=1 and s=1;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
update lwt set s=1 where p=1 and c=1 if s=1;
{
	"message" : "exceptions::invalid_request_exception (Invalid restrictions on clustering columns since the UPDATE statement modifies only static columns)",
	"status" : "error"
}
update lwt set s=1 where p=1 and c=1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Invalid restrictions on clustering columns since the UPDATE statement modifies only static columns)",
	"status" : "error"
}
delete from lwt where p=1 if exists;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
delete from lwt where p=1 if v=10;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
delete from lwt where p=1 and c>0 if exists;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
delete from lwt where p=1 and c>0 if v=10;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
delete v from lwt where p=1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Primary key column 'c' must be specified in order to modify column 'v')",
	"status" : "error"
}
delete v from lwt where p=1 if v=10;
{
	"message" : "exceptions::invalid_request_exception (Primary key column 'c' must be specified in order to modify column 'v')",
	"status" : "error"
}
delete v from lwt where p=1 and c>0 if exists;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
delete v from lwt where p=1 and c>0 if v=10;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
delete s from lwt where p=1 if v=1;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to use IF condition on non static columns)",
	"status" : "error"
}
delete s from lwt where p=1 if v=1 and s=1;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to use IF condition on non static columns)",
	"status" : "error"
}
delete s from lwt where p=1 and c=1 if s=1;
{
	"message" : "exceptions::invalid_request_exception (Invalid restrictions on clustering columns since the DELETE statement modifies only static columns)",
	"status" : "error"
}
delete s from lwt where p=1 and c=1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Invalid restrictions on clustering columns since the DELETE statement modifies only static columns)",
	"status" : "error"
}
drop table lwt;
{
	"status" : "ok"
}

-- mixing reading operations and static column conditions in one statement
create table lwt(p int, c int, s int static, v list<int>, primary key(p, c));
{
	"status" : "ok"
}
insert into lwt(p, c) values(1, 1);
{
	"status" : "ok"
}
insert into lwt(p, c, v) values(1, 2, [1, 2, 3]);
{
	"status" : "ok"
}
insert into lwt(p, c, s) values(1, 3, 1);
{
	"status" : "ok"
}
update lwt set v=v-[2] where p=1 and c=2 if s=1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "1"
		}
	]
}
select * from lwt;
{
	"rows" : 
	[
		{
			"c" : "1",
			"p" : "1",
			"s" : "1"
		},
		{
			"c" : "2",
			"p" : "1",
			"s" : "1",
			"v" : "[1, 3]"
		},
		{
			"c" : "3",
			"p" : "1",
			"s" : "1"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}

-- todo: conditional updates and views

--
-- collections: conditional updates and sets, maps, lists, frozen
-- sets, maps and lists
--
create table lwt (a int, b int, setint set<int>, setsetint set<frozen<set<int>>>, primary key (a, b));
{
	"status" : "ok"
}
insert into test (a, b) values (1,1);
{
	"message" : "exceptions::invalid_request_exception (unconfigured table test)",
	"status" : "error"
}
update lwt set setint={1, 2, 3}, setsetint = {{1,2,3}, {2,3,4}, {5,6,7}} where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : null
}
update lwt set setint=setint+{1, 2, 3}, setsetint = setsetint + {{7,8,9}} where a = 1 and b = 1 if setint = {1, 2, 3};
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : null
}
update lwt set setint=setint-{1, 2, 3}, setsetint = setsetint - {{1,2,3}} where a = 1 and b = 1  if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : null
}
drop table lwt;
{
	"status" : "ok"
}

create table lwt (a int, b int, mapint map<int, int>, mapsetint map<int, frozen<set<int>>>, primary key (a, b));
{
	"status" : "ok"
}
insert into lwt (a, b) values (1,1);
{
	"status" : "ok"
}
update lwt set mapint={1: 1, 2: 1, 3: 1}, mapsetint = {1: {1}, 2: {2}, 3: {3}} where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"mapint" : "{\"1\": 1, \"2\": 1, \"3\": 1}",
			"mapsetint" : "{\"1\": [1], \"2\": [2], \"3\": [3]}"
		}
	]
}
update lwt set mapsetint = mapsetint + {1: {3,4}} where a = 1 and b = 1 if mapint[2] = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"mapint" : "{\"1\": 1, \"2\": 1, \"3\": 1}"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"mapint" : "{\"1\": 1, \"2\": 1, \"3\": 1}",
			"mapsetint" : "{\"1\": [3, 4], \"2\": [2], \"3\": [3]}"
		}
	]
}
update lwt set mapint = mapint + {2: 1} where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1",
			"mapint" : "{\"1\": 1, \"2\": 1, \"3\": 1}",
			"mapsetint" : "{\"1\": [3, 4], \"2\": [2], \"3\": [3]}"
		}
	]
}
update lwt set mapint = mapint - {2} where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1",
			"mapint" : "{\"1\": 1, \"2\": 1, \"3\": 1}",
			"mapsetint" : "{\"1\": [3, 4], \"2\": [2], \"3\": [3]}"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"mapint" : "{\"1\": 1, \"3\": 1}",
			"mapsetint" : "{\"1\": [3, 4], \"2\": [2], \"3\": [3]}"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}

create table lwt (a int, b int, listint list<int>, staticsettext set<text> static, primary key(a, b));
{
	"status" : "ok"
}
insert into lwt (a, b) values (1,1);
{
	"status" : "ok"
}
update lwt set staticsettext = {'a', 'b', 'c'} where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
update lwt set staticsettext = {'d', 'e', 'f'} where a = 2 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
update lwt set staticsettext = staticsettext + {'d'}, listint = [1, 2, 3] where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"listint" : "[1, 2, 3]",
			"staticsettext" : "[\"d\"]"
		}
	]
}
update lwt set staticsettext = staticsettext + {'e'} where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1",
			"listint" : "[1, 2, 3]",
			"staticsettext" : "[\"d\"]"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"listint" : "[1, 2, 3]",
			"staticsettext" : "[\"d\", \"e\"]"
		}
	]
}
update lwt set listint = listint + [5] where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1",
			"listint" : "[1, 2, 3]",
			"staticsettext" : "[\"d\", \"e\"]"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"listint" : "[1, 2, 3, 5]",
			"staticsettext" : "[\"d\", \"e\"]"
		}
	]
}
update lwt set listint = [-1] + listint, staticsettext = staticsettext - {'e'} where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1",
			"listint" : "[1, 2, 3, 5]",
			"staticsettext" : "[\"d\", \"e\"]"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"listint" : "[-1, 1, 2, 3, 5]",
			"staticsettext" : "[\"d\"]"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}

create table lwt (a int, b int, flistint frozen<list<int>>, smapint map<text, int> static, primary key(a, b));
{
	"status" : "ok"
}
insert into lwt (a, b) values (1,1);
{
	"status" : "ok"
}
update lwt set smapint = {'a': 1, 'b': 1, 'c': 3} where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
update lwt set smapint = smapint + {'d': 3}, flistint = [1] where a = 1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part b)",
	"status" : "error"
}
update lwt set smapint = smapint + {'d': 4}, flistint = [1] where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"flistint" : "[1]",
			"smapint" : "{\"d\": 4}"
		}
	]
}
update lwt set flistint = [1, 2] where a = 1 and b = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "1",
			"flistint" : "[1]",
			"smapint" : "{\"d\": 4}"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"flistint" : "[1, 2]",
			"smapint" : "{\"d\": 4}"
		}
	]
}
update lwt set flistint = flistint + [3] where a = 1 and b = 1 if exists;
{
	"message" : "exceptions::invalid_request_exception (Invalid operation (flistint = flistint + [3]) for frozen collection column 666c697374696e74)",
	"status" : "error"
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"flistint" : "[1, 2]",
			"smapint" : "{\"d\": 4}"
		}
	]
}
update lwt set flistint = [4]  where a = 1 and b = 1 if smapint['a'] = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"smapint" : "{\"d\": 4}"
		}
	]
}
update lwt set flistint = [4]  where a = 1 and b = 1;
{
	"status" : "ok"
}
drop table lwt;
{
	"status" : "ok"
}
--
-- collection: ends
--
--
-- if expr grammar
--
create table lwt (a int, c int, listint list<int>, mapint map<int, int>, setint set<int>, primary key(a));
{
	"status" : "ok"
}
-- term
update lwt set c=0 where a = 1 if c;
{
	"message" : "exceptions::syntax_exception (line 1:35 no viable alternative at input ';')",
	"status" : "error"
}
-- -- equality
update lwt set c=0 where a = 1 if c = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
-- inequality: there is na inequality
update lwt set c=0 where a = 1 if c != 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
-- greater
update lwt set c=0 where a = 1 if c > 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "0"
		}
	]
}
-- less
update lwt set c=0 where a = 1 if c < 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "0"
		}
	]
}
-- greater equal
update lwt set c=0 where a = 1 if c >= 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "0"
		}
	]
}
-- less equal
update lwt set c=0 where a = 1 if c <= 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "0"
		}
	]
}
-- AND prediate
update lwt set c=0 where a = 1 if c = 1 and c = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "0"
		}
	]
}
-- OR predicate: Cassandra users do not deserve it :(
update lwt set c=0 where a = 1 if c = 1 or c = 1;
{
	"message" : "exceptions::syntax_exception (line 1:40  : syntax error...\n)",
	"status" : "error"
}
-- null
update lwt set c=0 where a = 1 if c = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "0"
		}
	]
}
-- in
update lwt set c=0 where a = 1 if c in (1);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "0"
		}
	]
}
-- in
update lwt set c=0 where a = 1 if c in (1, 2);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "0"
		}
	]
}
-- in (null)
update lwt set c=0 where a = 1 if c in (1, null);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "0"
		}
	]
}
-- list contains
update lwt set c=0 where a = 1 if listint contains null;
{
	"message" : "exceptions::syntax_exception (line 1:42 no viable alternative at input 'contains')",
	"status" : "error"
}
-- map contains
update lwt set c=0 where a = 1 if mapint contains key 1;
{
	"message" : "exceptions::syntax_exception (line 1:41 no viable alternative at input 'contains')",
	"status" : "error"
}
-- set contains
update lwt set c=0 where a = 1 if setint contains key 1;
{
	"message" : "exceptions::syntax_exception (line 1:41 no viable alternative at input 'contains')",
	"status" : "error"
}
-- multi-value set contaias
update lwt set c=0 where a = 1 if setint contains key 1;
{
	"message" : "exceptions::syntax_exception (line 1:41 no viable alternative at input 'contains')",
	"status" : "error"
}
-- addressing map element
update lwt set c=0 where a = 1 if mapint[2] = 3;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
-- addressing map element
update lwt set c=0 where a = 1 if mapint[2];
{
	"message" : "exceptions::syntax_exception (line 1:43 no viable alternative at input ';')",
	"status" : "error"
}
-- comparing map element and null
update lwt set c=0 where a = 1 if mapint[2] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
-- rinse and repeat with actual data
insert into lwt (a, c, listint, mapint, setint) values (1, 1, [1], {1: 1}, {1});
{
	"status" : "ok"
}
update lwt set c=1 where a = 1 if c = 0;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "1",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=2 where a = 1 if c != 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "1",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=3 where a = 1 if c > 0;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "3",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=4 where a = 1 if c < 2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "3"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "3",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=5 where a = 1 if c >= 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "3"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "5",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=6 where a = 1 if c <= 5;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "5"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "6",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=7 where a = 1 if c = 1 and c = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "6"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "6",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=8 where a = 1 if c = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "6"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "6",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=9 where a = 1 if c in (4);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "6"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "6",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=10 where a = 1 if c in (4, 5);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "6"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "6",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=11 where a = 1 if c in (5, null);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "6"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "6",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=12 where a = 1 if mapint[1] = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"mapint" : "{\"1\": 1}"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "12",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
update lwt set c=13 where a = 1 if mapint[1] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"mapint" : "{\"1\": 1}"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"c" : "12",
			"listint" : "[1]",
			"mapint" : "{\"1\": 1}",
			"setint" : "[1]"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
--
-- conditions: null handling
--
create table lwt (a int, b int, primary key(a));
{
	"status" : "ok"
}
insert into lwt (a) values (1);
{
	"status" : "ok"
}
-- null >|<|<=|<= val = false
update lwt set b = 1 where a = 1 if b > 3;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set b = 1 where a = 1 if b >= 3;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set b = 1 where a = 1 if b <= 3;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set b = 1 where a = 1 if b < 3;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
-- null >|<|<=|<= null = error
update lwt set b = 1 where a = 1 if b > null;
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \">\")",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if b >= null;
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \">=\")",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if b < null;
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \"<\")",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if b <= null;
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \"<=\")",
	"status" : "error"
}
-- cassandra doesn't allow this (ugh), but test nevertheless
update lwt set b = 1 where a = 1 if 3 < b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input '3')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if 3 <= b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input '3')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if 3 >= b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input '3')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if 3 > b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input '3')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if null < b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input 'null')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if null <= b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input 'null')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if null > b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input 'null')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if null >= b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input 'null')",
	"status" : "error"
}
update lwt set b = 1 where a = 1 if null = b;
{
	"message" : "exceptions::syntax_exception (line 1:36 no viable alternative at input 'null')",
	"status" : "error"
}
-- null == null = true
update lwt set b = 1 where a = 1 if b = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1"
		}
	]
}
-- val !=  null = true
update lwt set b = null where a = 1 if b != null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "1"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1"
		}
	]
}
update lwt set b = null where a = 1;
{
	"status" : "ok"
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1"
		}
	]
}
-- null != null  = false
update lwt set b = 1 where a = 1 if b != null;
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1"
		}
	]
}
-- null != val  = true
update lwt set b = 2 where a = 1 if b != 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select * from lwt allow filtering;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "2"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
--
-- conditions: simple expression
--
create table lwt (a int, b boolean, d decimal, f double, i int, s text, t timestamp, primary key(a));
{
	"status" : "ok"
}
insert into lwt (a, b, d, f, i, s, t) values (1, true, 1, 1, 1, '', dateof(now()));
{
	"status" : "ok"
}
-- boolean test
update lwt set b = false where a = 1 if b = true;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "true"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		{
			"b" : "false"
		}
	]
}
update lwt set b = true where a = 1 if b = true;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "false"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		{
			"b" : "false"
		}
	]
}
update lwt set b = true where a = 1 if b != true;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "false"
		}
	]
}
-- for whatever reason these operators are allowed for boolean values,
-- keep it this way
update lwt set b = true where a = 1 if b > true;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "true"
		}
	]
}
update lwt set b = true where a = 1 if b < false;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "true"
		}
	]
}
update lwt set b = true where a = 1 if b <= false;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "true"
		}
	]
}
update lwt set b = true where a = 1 if b >= true;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "true"
		}
	]
}
-- integer test
update lwt set i = 1 where a = 1 if i = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"i" : "1"
		}
	]
}
update lwt set i = 2 where a = 1 if i != 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"i" : "1"
		}
	]
}
update lwt set i = 3 where a = 1 if i < 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"i" : "1"
		}
	]
}
update lwt set i = 4 where a = 1 if i > 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"i" : "1"
		}
	]
}
update lwt set i = 5 where a = 1 if i >= 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"i" : "1"
		}
	]
}
update lwt set i = 6 where a = 1 if i <= 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"i" : "5"
		}
	]
}
-- Compare with another column: cassandra doesnt allow anyting but a
-- constant on the right hand side :(
update lwt set i = 7 where a = 1 if i = t;
{
	"message" : "exceptions::syntax_exception (line 1:41 no viable alternative at input ';')",
	"status" : "error"
}
update lwt set i = 7 where a = 1 if i = d;
{
	"message" : "exceptions::syntax_exception (line 1:41 no viable alternative at input ';')",
	"status" : "error"
}
update lwt set i = 7 where a = 1 if i = f;
{
	"message" : "exceptions::syntax_exception (line 1:41 no viable alternative at input ';')",
	"status" : "error"
}
update lwt set i = 7 where a = 1 if s = i;
{
	"message" : "exceptions::syntax_exception (line 1:41 no viable alternative at input ';')",
	"status" : "error"
}
-- float test
update lwt set f = 2 where a = 1 if f = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"f" : "1"
		}
	]
}
update lwt set f = 3 where a = 1 if f != 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"f" : "2"
		}
	]
}
update lwt set f = 4 where a = 1 if f < 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"f" : "3"
		}
	]
}
update lwt set f = 5 where a = 1 if f > 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"f" : "3"
		}
	]
}
update lwt set f = 6 where a = 1 if f >= 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"f" : "5"
		}
	]
}
update lwt set f = 7 where a = 1 if f <= 1;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"f" : "6"
		}
	]
}
-- this is broken, obviously
update lwt set f = 8 where a = 1 if f != 6.0000000000000001;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"f" : "6"
		}
	]
}
-- decimal
update lwt set d = 2.1 where a = 1 if d = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "1"
		}
	]
}
update lwt set d = 3.2 where a = 1 if d != 2.09999999999999999999999999999999999;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "2.1"
		}
	]
}
update lwt set d = 4.3 where a = 1 if d < 3.2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "3.2"
		}
	]
}
update lwt set d = 5.4 where a = 1 if d > 3.2;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "3.2"
		}
	]
}
update lwt set d = 6.5 where a = 1 if d >= 3.2;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "3.2"
		}
	]
}
update lwt set d = 7.6 where a = 1 if d <= 6.5;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "6.5"
		}
	]
}
-- text
update lwt set s = 'i' where a = 1 if s = '';
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "\"\""
		}
	]
}
-- update lwt set s = 'щ' where a = 1 if s != 'j';
-- wheeled charriot and left-to-right
-- update lwt set s = ' 𐃌   ' where a = 1 if s < 'я';
-- update lwt set s = 'שׁלום' where a = 1 if s >= '1';
select s from lwt where a = 1;
{
	"rows" : 
	[
		{
			"s" : "\"i\""
		}
	]
}
-- timestamp test
-- update lwt set t = dateof(now()) where a = 1 if t <= dateof(now());
drop table lwt;
{
	"status" : "ok"
}
-- map keys
create table lwt (a int, b map<boolean, boolean>, c list<boolean>, s set<boolean>, primary key (a));
{
	"status" : "ok"
}
insert into lwt (a, b) values (1, {true: true});
{
	"status" : "ok"
}
update lwt set b = {true:false} where a = 1 if b[true] = true;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"true\": true}"
		}
	]
}
update lwt set b = {true:false} where a = 1 if b[true] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"true\": false}"
		}
	]
}
update lwt set b = {false:true} where a = 1 if b[false] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"true\": false}"
		}
	]
}
update lwt set b = {false:false} where a = 1 if b[true] != null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b[true] = false where a = 1 if b[true] != 1;
{
	"message" : "exceptions::invalid_request_exception (Invalid INTEGER constant (1) for \"value(b)\" of type boolean)",
	"status" : "error"
}
update lwt set b[false] = null where a = 1 if b[true] > null;
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \">\")",
	"status" : "error"
}
update lwt set b[false] = true where a = 1 if b[1] != true;
{
	"message" : "exceptions::invalid_request_exception (Invalid INTEGER constant (1) for \"key(b)\" of type boolean)",
	"status" : "error"
}
update lwt set b = {true:false, true:true, false:false} where a = 1 if b[null] = null;
{
	"message" : "exceptions::invalid_request_exception (Invalid null value for map<boolean, boolean> element access)",
	"status" : "error"
}
update lwt set b = b + {false:true} where a = 1 if b[null] = true;
{
	"message" : "exceptions::invalid_request_exception (Invalid null value for map<boolean, boolean> element access)",
	"status" : "error"
}
update lwt set b[null] = false where a = 1 if b[true] != true;
{
	"message" : "exceptions::invalid_request_exception (Invalid null map key)",
	"status" : "error"
}
update lwt set b[null] = false where a = 1 if b[true] = true;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"false\": true}"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		{
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b = {false:true} where a = 1 if b = {true:false};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b = {} where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b = {} where a = 1 if b = {};
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		null
	]
}
update lwt set b = {} where a = 1 if b = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		null
	]
}
update lwt set b = null where a = 1 if b = {};
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		null
	]
}
-- lists
-- null value == empty list. see CASSANDRA-7155
update lwt set c = [false] where a = 1 if c = [];
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
-- c is null, really, so this should work
update lwt set c = [] where a = 1 if c = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[false]"
		}
	]
}
-- check with empty list
update lwt set c = [false] where a = 1 if c = [];
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[false]"
		}
	]
}
update lwt set c = [false] where a = 1 if c = [false];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[false]"
		}
	]
}
update lwt set c = [false] where a = 1 if c = [null];
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set c = [false] where a = 1 if c = [null, true];
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
select c from lwt where a = 1;
{
	"rows" : 
	[
		{
			"c" : "[false]"
		}
	]
}
update lwt set c = [true, false] where a = 1 if c[0] = false;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[false]"
		}
	]
}
update lwt set c = c + [true] where a = 1 if c[1] = false;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[true, false]"
		}
	]
}
update lwt set c = c + [false] where a = 1 if c[2] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[true, false, true]"
		}
	]
}
update lwt set c = c + [true] where a = 1 if c[3] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[true, false, true]"
		}
	]
}
update lwt set c = c + [true] where a = 1 if c[100000000] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[true, false, true, true]"
		}
	]
}
update lwt set c = c + [false] where a = 1 if c[100000000] = true;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[true, false, true, true, true]"
		}
	]
}
update lwt set c = c + [true, false] where a = 1 if c[null] = false;
{
	"message" : "exceptions::invalid_request_exception (Invalid null value for map<timeuuid, boolean> element access)",
	"status" : "error"
}
update lwt set c = [false] where a = 1 if c[null] = null;
{
	"message" : "exceptions::invalid_request_exception (Invalid null value for map<timeuuid, boolean> element access)",
	"status" : "error"
}
update lwt set c = c + [false] where a = 1 if c[null] = 1;
{
	"message" : "exceptions::invalid_request_exception (Invalid INTEGER constant (1) for \"value(c)\" of type boolean)",
	"status" : "error"
}
update lwt set c = [true] + c where a = 1 if c = [false];
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[true, false, true, true, true]"
		}
	]
}
select c from lwt where a = 1;
{
	"rows" : 
	[
		{
			"c" : "[true, false, true, true, true]"
		}
	]
}
-- sets
-- null value == empty set
update lwt set s = {} where a = 1 if s = {};
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set s = {} where a = 1 if s = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set s = {false} where a = 1 if s = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set s = {true, false} where a = 1 if s = {false};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "[false]"
		}
	]
}
update lwt set s = {false} where a = 1 if s = {null};
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set s = {false} where a = 1 if s = {null, true};
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set s = {true, false} where a = 1 if s{true} = false;
{
	"message" : "exceptions::syntax_exception (line 1:49 no viable alternative at input '{')",
	"status" : "error"
}
update lwt set s = {false} where a = 1 if s = 1;
{
	"message" : "exceptions::invalid_request_exception (Invalid INTEGER constant (1) for \"s\" of type set<boolean>)",
	"status" : "error"
}
update lwt set s = {true} + s where a = 1 if s = {false};
{
	"message" : "exceptions::invalid_request_exception (Invalid operation (s = {true} + s) for non list column 73)",
	"status" : "error"
}
-- sets
-- null value == empty set
update lwt set s = {} where a = 1 if s = {};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[false, true]"
		}
	]
}
update lwt set s = {} where a = 1 if s = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[false, true]"
		}
	]
}
update lwt set s = {false} where a = 1 if s = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[false, true]"
		}
	]
}
update lwt set s = {true, false} where a = 1 if s = {false};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[false, true]"
		}
	]
}
update lwt set s = {false} where a = 1 if s = {null};
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set s = {false} where a = 1 if s = {null, true};
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set s = {true, false} where a = 1 if s{true} = false;
{
	"message" : "exceptions::syntax_exception (line 1:49 no viable alternative at input '{')",
	"status" : "error"
}
update lwt set s = {false} where a = 1 if s = 1;
{
	"message" : "exceptions::invalid_request_exception (Invalid INTEGER constant (1) for \"s\" of type set<boolean>)",
	"status" : "error"
}
update lwt set s = {true} + s where a = 1 if s = {false};
{
	"message" : "exceptions::invalid_request_exception (Invalid operation (s = {true} + s) for non list column 73)",
	"status" : "error"
}
drop table lwt;
{
	"status" : "ok"
}
--
-- frozen collections
--
create table lwt (a int, b frozen<map<boolean, boolean>>, c frozen<list<boolean>>, s frozen<set<boolean>>, primary key (a));
{
	"status" : "ok"
}
insert into lwt (a, b) values (1, {true: true});
{
	"status" : "ok"
}
update lwt set b = {true:false} where a = 1 if b[true] = true;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"true\": true}"
		}
	]
}
update lwt set b = {true:false} where a = 1 if b[true] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"true\": false}"
		}
	]
}
update lwt set b = {false:true} where a = 1 if b[false] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"true\": false}"
		}
	]
}
update lwt set b = {false:false} where a = 1 if b[true] != null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b[true] = false where a = 1 if b[true] != true;
{
	"message" : "exceptions::invalid_request_exception (Invalid operation (b[true] = false) for frozen collection column 62)",
	"status" : "error"
}
update lwt set b = b + {false:true} where a = 1 if b[true] = true;
{
	"message" : "exceptions::invalid_request_exception (Invalid operation (b = b + {false:true}) for frozen collection column 62)",
	"status" : "error"
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		{
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b = {false:true} where a = 1 if b = {true:false};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b = {} where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"b" : "{\"false\": true}"
		}
	]
}
update lwt set b = {} where a = 1 if b = {};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{}"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		{
			"b" : "{}"
		}
	]
}
update lwt set b = {} where a = 1 if b = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{}"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		{
			"b" : "{}"
		}
	]
}
update lwt set b = null where a = 1 if b = {};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{}"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		null
	]
}
-- lists
-- null value != empty list for a frozen list
update lwt set c = [false] where a = 1 if c = [];
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
-- c is null, really, so this should work
update lwt set c = [] where a = 1 if c = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
-- check with empty list
update lwt set c = [false] where a = 1 if c = [];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[]"
		}
	]
}
update lwt set c = [false] where a = 1 if c = [false];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[false]"
		}
	]
}
update lwt set c = [false] where a = 1 if c = [null];
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set c = [false] where a = 1 if c = [null, true];
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
select c from lwt where a = 1;
{
	"rows" : 
	[
		{
			"c" : "[false]"
		}
	]
}
-- negative list index
update lwt set c = [true, false] where a = 1 if c[-1] = false;
{
	"message" : "exceptions::invalid_request_exception (Invalid negative list index -1)",
	"status" : "error"
}
update lwt set c = [true, false] where a = 1 if c[-1.5] = false;
{
	"message" : "exceptions::invalid_request_exception (Invalid FLOAT constant (-1.5) for \"idx(c)\" of type int)",
	"status" : "error"
}
update lwt set c = [true, false] where a = 1 if c[0] = false;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[false]"
		}
	]
}
update lwt set c = [true] where a = 1 if c[1] = false;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[true, false]"
		}
	]
}
update lwt set c = [true, false] where a = 1 if c[2] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[true]"
		}
	]
}
update lwt set c = [true] where a = 1 if c[100000000] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[true, false]"
		}
	]
}
update lwt set c = [false] where a = 1 if c[null] = null;
{
	"message" : "exceptions::invalid_request_exception (Invalid null value for frozen<list<boolean>> element access)",
	"status" : "error"
}
update lwt set c = [true] + c where a = 1 if c = [false];
{
	"message" : "exceptions::invalid_request_exception (Invalid operation (c = [true] + c) for frozen list column 63)",
	"status" : "error"
}
update lwt set c = [true,true,true,false,false,false] where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"c" : "[true]"
		}
	]
}
update lwt set c = null where a = 1 if c[1] = true and c[5] = false and c[7] = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[true, true, true, false, false, false]"
		}
	]
}
select c from lwt where a = 1;
{
	"rows" : 
	[
		null
	]
}
-- sets
-- null value == empty set
update lwt set s = {} where a = 1 if s = {};
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set s = {} where a = 1 if s = null;
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set s = {false} where a = 1 if s = null;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[]"
		}
	]
}
update lwt set s = {true, false} where a = 1 if s = {false};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[]"
		}
	]
}
update lwt set s = {false} where a = 1 if s = {null};
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set s = {false} where a = 1 if s = {null, true};
{
	"message" : "exceptions::invalid_request_exception (null is not supported inside collections)",
	"status" : "error"
}
update lwt set s = {true, false} where a = 1 if s{true} = false;
{
	"message" : "exceptions::syntax_exception (line 1:49 no viable alternative at input '{')",
	"status" : "error"
}
update lwt set s = s + {true} where a = 1 if s = {true, false};
{
	"message" : "exceptions::invalid_request_exception (Invalid operation (s = s + {true}) for frozen collection column 73)",
	"status" : "error"
}
update lwt set s = {true, true} where a = 1 if exists;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"a" : "1",
			"s" : "[]"
		}
	]
}
-- check non frozen sets are compared correctly to set literals
update lwt set s = {false, false} where a = 1 if  s = {true, true};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "[true]"
		}
	]
}
update lwt set s = {false, true} where a = 1 if  s = {true, false};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[false]"
		}
	]
}
select s from lwt where a = 1;
{
	"rows" : 
	[
		{
			"s" : "[false]"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
-- gt/le on composite collections
create table lwt (a int, b map<int, int>, c list<int>, s set<int>, primary key (a));
{
	"status" : "ok"
}
insert into lwt (a, b, c, s) values (1, {}, [], {});
{
	"status" : "ok"
}
-- maps
update lwt set b = {1:1} where a = 1 if b > {};
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \">\")",
	"status" : "error"
}
update lwt set b = {1:1} where a = 1 if b < {};
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \"<\")",
	"status" : "error"
}
update lwt set b = {1:1} where a = 1 if b = {};
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set b = {2:2} where a = 1 if b > {1:1};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"1\": 1}"
		}
	]
}
update lwt set b = {2:2} where a = 1 if b >= {1:1};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"1\": 1}"
		}
	]
}
update lwt set b = {3:3} where a = 1 if b > {1:1};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"2\": 2}"
		}
	]
}
update lwt set b = {4:4} where a = 1 if b >= {2:3};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"3\": 3}"
		}
	]
}
update lwt set b = {4:4} where a = 1 if b >= {3:3};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"4\": 4}"
		}
	]
}
update lwt set b = {1:1} where a = 1 if b < {4:4};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "{\"4\": 4}"
		}
	]
}
update lwt set b = {1:1} where a = 1 if b <= {4:4};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "{\"4\": 4}"
		}
	]
}
select b from lwt where a= 1;
{
	"rows" : 
	[
		{
			"b" : "{\"1\": 1}"
		}
	]
}
-- lists
update lwt set c = [1,1] where a = 1 if c > [];
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \">\")",
	"status" : "error"
}
update lwt set c = [1,1] where a = 1 if c < [];
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \"<\")",
	"status" : "error"
}
update lwt set c = [1,1] where a = 1 if c = [];
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set c = [2,2] where a = 1 if c > [1,1];
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[1, 1]"
		}
	]
}
update lwt set c = [2,2] where a = 1 if c >= [1,1];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[1, 1]"
		}
	]
}
update lwt set c = [3,3] where a = 1 if c > [1,1];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[2, 2]"
		}
	]
}
update lwt set c = [4,4] where a = 1 if c >= [2,3];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[3, 3]"
		}
	]
}
update lwt set c = [4,4] where a = 1 if c >= [3,3];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[4, 4]"
		}
	]
}
update lwt set c = [1,1] where a = 1 if c < [4,4];
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[4, 4]"
		}
	]
}
update lwt set c = [1,1] where a = 1 if c <= [4,4];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[4, 4]"
		}
	]
}
select c from lwt where a= 1;
{
	"rows" : 
	[
		{
			"c" : "[1, 1]"
		}
	]
}
-- sets
update lwt set s = {1} where a = 1 if s > {};
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \">\")",
	"status" : "error"
}
update lwt set s = {1} where a = 1 if s < {};
{
	"message" : "exceptions::invalid_request_exception (Invalid comparison with null for operator \"<\")",
	"status" : "error"
}
update lwt set s = {1} where a = 1 if s = {};
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set s = {2} where a = 1 if s > {1};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[1]"
		}
	]
}
update lwt set s = {2} where a = 1 if s >= {1};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "[1]"
		}
	]
}
update lwt set s = {3} where a = 1 if s > {1};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "[2]"
		}
	]
}
update lwt set s = {4} where a = 1 if s >= {3};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "[3]"
		}
	]
}
update lwt set s = {1} where a = 1 if s < {4};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"s" : "[4]"
		}
	]
}
update lwt set s = {1} where a = 1 if s <= {4};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"s" : "[4]"
		}
	]
}
select s from lwt where a= 1;
{
	"rows" : 
	[
		{
			"s" : "[1]"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
-- collections of collections
-- non-frozen nested sets are not supported
create table lwt (a int, b set<map<int,int>>, c list<set<int>>, primary key (a));
{
	"message" : "exceptions::invalid_request_exception (Non-frozen user types or collections are not allowed inside collections: list<set<int>>)",
	"status" : "error"
}
-- frozen collection elements are however ok
create table lwt (a int, b set<frozen<list<int>>>, c list<frozen<set<int>>>, primary key (a));
{
	"status" : "ok"
}
insert into lwt (a, b, c) values (1, {[1,2], [1,2]}, [{1,2}, {1,2}]);
{
	"status" : "ok"
}
-- sets
update lwt set b={[3,3], [4,4]} where a = 1 if b = {[1,2], [1,2]};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "[[1, 2]]"
		}
	]
}
update lwt set b={[5,5,5], [4,4,4]} where a = 1 if b > {[3,3], [4,4]};
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"b" : "[[3, 3], [4, 4]]"
		}
	]
}
update lwt set b={[5,5,5], [4,4,4]} where a = 1 if b >= {[3,3], [4,4]};
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"b" : "[[3, 3], [4, 4]]"
		}
	]
}
select b from lwt where a = 1;
{
	"rows" : 
	[
		{
			"b" : "[[4, 4, 4], [5, 5, 5]]"
		}
	]
}
-- lists
update lwt set c=[{3,4}, {4,5}] where a = 1 if c = [{1,2}, {1,2}];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[[1, 2], [1, 2]]"
		}
	]
}
update lwt set c=[{3,4,5}, {4,5,6}] where a = 1 if c > [{3,3}, {4,4}];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[[3, 4], [4, 5]]"
		}
	]
}
update lwt set c=[{5,6,7}, {7,8,9}] where a = 1 if c >= [{3,3}, {5,4}];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[[3, 4, 5], [4, 5, 6]]"
		}
	]
}
update lwt set c=[{5,6,7}, {7,8,9}] where a = 1 if c >= [{3,4}, {4,5}];
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[[5, 6, 7], [7, 8, 9]]"
		}
	]
}
select c from lwt where a = 1;
{
	"rows" : 
	[
		{
			"c" : "[[5, 6, 7], [7, 8, 9]]"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
-- in predicate, static columns
create table lwt (a int, b int, c list<int>, d set<int> static, primary key (a, b));
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,[1],{1});
{
	"status" : "ok"
}
update lwt set d = {2,3,4,5,-1} where a = 1 if d in ({1});
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "[1]"
		}
	]
}
update lwt set d = {2} where a = 1 if d in ({2,3,4,5});
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "[-1, 2, 3, 4, 5]"
		}
	]
}
update lwt set d = {2} where a = 1 if d in ({2,3,4,5,-1});
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "[-1, 2, 3, 4, 5]"
		}
	]
}
update lwt set c = [2,3,4,5,-1] where a = 1 and b = 1 if c in ([1]);
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[1]"
		}
	]
}
update lwt set c = [2] where a = 1 and b = 1 if c in ([2,3,4,5]);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[2, 3, 4, 5, -1]"
		}
	]
}
-- check null handling in IN condition
update lwt set c = [] where a = 1 and b = 1 if c in ([2,3,4,5,-1]);
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[2, 3, 4, 5, -1]"
		}
	]
}
update lwt set c = null where a = 1 and b = 1 if c in ([]);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set c = null where a = 1 and b = 1 if c in ([]);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set c = null where a = 1 and b = 1 if c in (null);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set c = [1] where a = 1 and b = 1 if c in ();
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set c = [2] where a = 1 and b = 1 if c in ([1], null, [2]);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
delete from lwt where a = 1;
{
	"status" : "ok"
}
update lwt set d = {2} where a = 1 if d in ();
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set d = {2} where a = 1 if d in (null);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set d = {} where a = 1 if d in ({}, {2});
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "[2]"
		}
	]
}
update lwt set d = {} where a = 1 if d in (null, {2});
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set d = null where a = 1 if d in (null, {2});
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set d = null where a = 1 if d in (null, {2}, {3,4}, {5});
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}

-- in predicate, frozen sets/lists columns
create table lwt (a int, b int, c frozen<list<int>>, d frozen<set<int>> static, primary key (a, b));
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,[1],{1});
{
	"status" : "ok"
}
update lwt set d = {2,3,4,5,-1} where a = 1 if d in ({1});
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "[1]"
		}
	]
}
update lwt set d = {2} where a = 1 if d in ({2,3,4,5});
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "[-1, 2, 3, 4, 5]"
		}
	]
}
update lwt set d = {2} where a = 1 if d in ({2,3,4,5,-1});
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "[-1, 2, 3, 4, 5]"
		}
	]
}
update lwt set c = [2,3,4,5,-1] where a = 1 and b = 1 if c in ([1]);
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[1]"
		}
	]
}
update lwt set c = [2] where a = 1 and b = 1 if c in ([2,3,4,5]);
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"c" : "[2, 3, 4, 5, -1]"
		}
	]
}
-- check null handling in IN condition
update lwt set c = [] where a = 1 and b = 1 if c in ([2,3,4,5,-1]);
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[2, 3, 4, 5, -1]"
		}
	]
}
update lwt set c = null where a = 1 and b = 1 if c in ([]);
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"c" : "[]"
		}
	]
}
update lwt set c = null where a = 1 and b = 1 if c in ([]);
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set c = null where a = 1 and b = 1 if c in (null);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set c = [1] where a = 1 and b = 1 if c in ();
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set c = [2] where a = 1 and b = 1 if c in ([1], null, [2]);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
delete from lwt where a = 1;
{
	"status" : "ok"
}
update lwt set d = {2} where a = 1 if d in ();
{
	"rows" : 
	[
		{
			"[applied]" : "false"
		}
	]
}
update lwt set d = {2} where a = 1 if d in (null);
{
	"rows" : 
	[
		{
			"[applied]" : "true"
		}
	]
}
update lwt set d = {} where a = 1 if d in ({}, {2});
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "[2]"
		}
	]
}
update lwt set d = {} where a = 1 if d in (null, {2});
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "[]"
		}
	]
}
update lwt set d = null where a = 1 if d in (null, {2});
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "[]"
		}
	]
}
update lwt set d = null where a = 1 if d in (null, {2}, {3,4}, {5});
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "[]"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
-- LWT and slices; a slice is a Cassandra term for a clustering key range,
-- usually within the same partition key
create table lwt (a int, b int, c int, d int, primary key (a, b, c));
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,1,1);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,2,0);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,3,1);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,2,1,1);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,2,2,0);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,2,3,1);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,3,1,1);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,3,2,0);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,3,3,1);
{
	"status" : "ok"
}
-- update
select d from lwt    where a = 1 and b = 1;
{
	"rows" : 
	[
		{
			"d" : "1"
		},
		{
			"d" : "0"
		},
		{
			"d" : "1"
		}
	]
}
update lwt set d = 7 where a = 1 and b = 1 if d = 0;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
select d from lwt    where a = 1 and b = 1;
{
	"rows" : 
	[
		{
			"d" : "1"
		},
		{
			"d" : "0"
		},
		{
			"d" : "1"
		}
	]
}
select d from lwt    where a = 1 and b = 2;
{
	"rows" : 
	[
		{
			"d" : "1"
		},
		{
			"d" : "0"
		},
		{
			"d" : "1"
		}
	]
}
update lwt set d = 7 where a = 1 and b = 2;
{
	"message" : "exceptions::invalid_request_exception (Missing mandatory PRIMARY KEY part c)",
	"status" : "error"
}
-- delete
select a, b, c, d from lwt where a = 1 and b = 1;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"c" : "1",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "2",
			"d" : "0"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "3",
			"d" : "1"
		}
	]
}
delete from lwt            where a = 1 and b = 1 if d = 0;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
select a, b, c, d from lwt where a = 1 and b = 1;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"c" : "1",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "2",
			"d" : "0"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "3",
			"d" : "1"
		}
	]
}
select a, b, c, d from lwt where a = 1 and b = 2;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "2",
			"c" : "1",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "2",
			"c" : "2",
			"d" : "0"
		},
		{
			"a" : "1",
			"b" : "2",
			"c" : "3",
			"d" : "1"
		}
	]
}
delete from lwt            where a = 1 and b = 2 if d = 1;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
select a, b, c, d from lwt where a = 1 and b = 2;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "2",
			"c" : "1",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "2",
			"c" : "2",
			"d" : "0"
		},
		{
			"a" : "1",
			"b" : "2",
			"c" : "3",
			"d" : "1"
		}
	]
}
select a, b, c, d from lwt where a = 1 and b = 3;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "3",
			"c" : "1",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "3",
			"c" : "2",
			"d" : "0"
		},
		{
			"a" : "1",
			"b" : "3",
			"c" : "3",
			"d" : "1"
		}
	]
}
delete from lwt            where a = 1 and b = 3;
{
	"status" : "ok"
}
select a, b, c, d from lwt where a = 1 and b = 3;
{
	"rows" : null
}
drop table lwt;
{
	"status" : "ok"
}
-- ok to delete if d is static
create table lwt (a int, b int, c int, d int static, primary key (a, b, c));
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,1,1);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,2,1);
{
	"status" : "ok"
}
insert into lwt (a, b, c, d) values (1,1,3,1);
{
	"status" : "ok"
}
select a, b, c, d from lwt where a = 1 and b = 1;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"c" : "1",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "2",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "3",
			"d" : "1"
		}
	]
}
-- try to delete all - fail
delete from lwt            where a = 1 and b = 1 if d = 0;
{
	"message" : "exceptions::invalid_request_exception (DELETE statements must restrict all PRIMARY KEY columns with equality relations in order to delete non static columns)",
	"status" : "error"
}
-- ok to delete static row
delete d from lwt          where a = 1 if d = 0;
{
	"rows" : 
	[
		{
			"[applied]" : "false",
			"d" : "1"
		}
	]
}
select a, b, c, d from lwt where a = 1;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"c" : "1",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "2",
			"d" : "1"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "3",
			"d" : "1"
		}
	]
}
delete d from lwt          where a = 1 if d = 1;
{
	"rows" : 
	[
		{
			"[applied]" : "true",
			"d" : "1"
		}
	]
}
select a, b, c, d from lwt where a = 1;
{
	"rows" : 
	[
		{
			"a" : "1",
			"b" : "1",
			"c" : "1"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "2"
		},
		{
			"a" : "1",
			"b" : "1",
			"c" : "3"
		}
	]
}
drop table lwt;
{
	"status" : "ok"
}
--
-- lists, sets, maps as partition or primary keys
--
-- This is covered with tests since with collections_as_maps
-- flags, sets/ints in primary key will make it difficult
-- to find the matching cells
--
-- invalid collection type
create table lwt (a int, b int, c set<int>, primary key (a, b, c));
{
	"message" : "exceptions::invalid_request_exception (Invalid non-frozen collection type for PRIMARY KEY component c)",
	"status" : "error"
}
-- ok - frozen collections are allowed
create table lwt (a int, b int, c frozen<list<int>>, primary key (a, b, c));
{
	"status" : "ok"
}
drop table lwt;
{
	"status" : "ok"
}
-- invalid collection type
create table lwt (a list<int>, b int, c int, primary key (a, b, c));
{
	"message" : "exceptions::invalid_request_exception (Invalid non-frozen collection type for PRIMARY KEY component a)",
	"status" : "error"
}
--
-- test empty primary key range: it is impossible to construct due to
-- limitations of the query language
--
create table lwt (a int, b int, c int, primary key (a, b));
{
	"status" : "ok"
}
-- error: can't use token and non-token restrictions
update lwt set c = 1 where a = 1 and b = 1 and token(a) > 0 and token(a) < 0 if c = 1;
{
	"message" : "exceptions::invalid_request_exception (Columns \"ColumnDefinition{name=a, type=org.apache.cassandra.db.marshal.Int32Type, kind=PARTITION_KEY, componentIndex=0, droppedAt=-9223372036854775808}\" cannot be restricted by both a normal relation and a token relation)",
	"status" : "error"
}
-- error: can't use eq and non-eq restriction 
update lwt set c = 1 where a = 1 and b = 1 and a < 0 if c = 1;
{
	"message" : "exceptions::invalid_request_exception (Only EQ and IN relation are supported on the partition key (unless you use the token() function or allow filtering))",
	"status" : "error"
}
update lwt set c = 1 where a = 1 and b = 1 and a < 0 if c = 1;
{
	"message" : "exceptions::invalid_request_exception (Only EQ and IN relation are supported on the partition key (unless you use the token() function or allow filtering))",
	"status" : "error"
}
-- error: partition key must be fully restricted
update lwt set c = 1 where a > 0 and a < 0 and b = 1 if c = 1;
{
	"message" : "exceptions::invalid_request_exception (Only EQ and IN relation are supported on the partition key (unless you use the token() function or allow filtering))",
	"status" : "error"
}
-- error: partition key and IN is not supported 
update lwt set c = 1 where a in () and b = 1 if c = 1;
{
	"message" : "exceptions::invalid_request_exception (IN on the partition key is not supported with conditional updates)",
	"status" : "error"
}
update lwt set c = 1 where a = 1 and b IN (1, 2) if c = 1;
{
	"message" : "exceptions::invalid_request_exception (IN on the clustering key columns is not supported with conditional updates)",
	"status" : "error"
}
update lwt set c = 1 where a = 1 and (b) IN ((1), (2)) if c = 1;
{
	"message" : "exceptions::invalid_request_exception (IN on the clustering key columns is not supported with conditional updates)",
	"status" : "error"
}
drop table lwt;
{
	"status" : "ok"
}
