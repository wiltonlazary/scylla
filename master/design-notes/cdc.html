


<!doctype html>
<html class="no-js" lang="en">
  
<head><!-- begin head.html -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
    CDC | Scylla Docs
    </title>
    <meta name="description" content="Scylla is an Apache Cassandra-compatible NoSQL data store that can handle 1 million transactions per second on a single server."/>

    <link rel="icon" href="../_static/img/favicon.ico" type="image/x-icon"/>
    <link rel="canonical" href="https://docs.scylladb.com/">

    <link rel="author" href="mailto:info@scylladb.com">
    <link rel="stylesheet" href="../_static/" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/tabs.css" />
    
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,100,300,500,700' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.2/css/foundation.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/doc/main.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>

    <script src="../_static/js/vendor/modernizr.js"></script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-T8P2JP');</script>
    <!-- End Google Tag Manager -->

    <!-- Marketo -->
    <script type="text/javascript"> (function() { var didInit = false; function initMunchkin() { if(didInit === false) { didInit = true; Munchkin.init('791-QBF-350'); } } var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = '//munchkin.marketo.net/munchkin.js'; s.onreadystatechange = function() { if (this.readyState == 'complete' || this.readyState == 'loaded') { initMunchkin(); } }; s.onload = initMunchkin; document.getElementsByTagName('head')[0].appendChild(s); })(); </script>
    <!-- End Marketo -->

<!-- end head.html -->
</head>

<body>


    <section class="custom-promo-banner-wrap">
    <div class="custom-promo-banner--relative">
        <div class="custom-promo-banner--img-left">
            <img src="../_static/img/Scylla-Summit-Banner-globs-left.svg">
        </div>
        <div class="custom-promo-banner--img-center">
            <img src="../_static/img/Scylla-Summit-Banner-globs-middle.svg">
        </div>
        <div class="custom-promo-banner--img-right">
            <img src="../_static/img/Scylla-Summit-Banner-globs-right.svg">
        </div>

        <div class="custom-promo-banner">
            <img class="custom-promo-banner--logo" src="../_static/img/slide-summit21-logo@2x.png" alt="">
            <div class="custom-promo-banner--title summit">Database Monsters of the World Connect! Virtual Conference | January 12-14</div>
            <a class="custom-promo-banner--button summit" href="https://scylladb.com/scylla-summit-2021/">Register Now <i class="fa fa-angle-right" style="margin-left: 10px;" aria-hidden="true"></i></a><button class="custom-promo-banner--close">×</button>
        </div>
    </div>
</section>



<header id="header" class="animated">
    <div class="topbar_continer contain-to-grid clearfix">
        <nav class="top-bar" id="top-bar" data-topbar role="navigation">
            <ul class="title-area">
                <li class="name">
                    <div class="logo">
                        <a href="https://docs.scylladb.com/"><img src="../_static/img/logo-scylla-docs.svg" alt="" width="151"></a>
                    </div>
                </li>
                <li class="toggle-topbar"><a href="#"><span class="icon-manu"></span></a></li>
            </ul>
            <section class="top-bar-section clearfix">
                <ul class="right">
                    
                    <li>
                        <a href="https://scylladb.github.io/scylla">Scylla Developer Notes</a>
                    </li>
                    
                    <li>
                        <a href="https://university.scylladb.com/">Scylla University</a>
                    </li>
                    
                    <li>
                        <a href="https://www.scylladb.com/">ScyllaDB Home</a>
                    </li>
                    
                    <li class="search_continer show-for-medium-up">	
                        <ci-search></ci-search>	
                    </li>	
                </ul>
            </section>
        </nav>
    </div>
</header>
<section id="content">
    <div class="row">
	
	<div class="large-6 large-push-3 columns">

        

        <div class="section" id="cdc">
<h1>CDC<a class="headerlink" href="#cdc" title="Permalink to this headline">¶</a></h1>
<div class="section" id="stream-ids">
<h2>Stream IDs<a class="headerlink" href="#stream-ids" title="Permalink to this headline">¶</a></h2>
<p>A <strong>stream ID</strong> is a 128-bit number, represented as a pair of <code class="docutils literal notranslate"><span class="pre">int64</span></code>s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">stream_id</span> <span class="n">final</span> <span class="p">{</span>
    <span class="n">int64_t</span> <span class="n">_first</span><span class="p">;</span>
    <span class="n">int64_t</span> <span class="n">_second</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
    <span class="o">...</span> <span class="n">methods</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When a write is performed to a CDC-enabled user-created table (the “base table”), a corresponding write, or a set of writes, is synchronously performed to the CDC table associated with the base table (the “log table”); the partition key for these log writes is chosen from some set of stream IDs. Where this set comes from and how those stream IDs are chosen is described below.</p>
<p>The 128 bits are composed of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">128</span>           <span class="mi">64</span>            <span class="mi">27</span>            <span class="mi">4</span>             <span class="mi">0</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="n">token</span><span class="p">:</span><span class="mi">64</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">random</span><span class="p">:</span><span class="mi">38</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">index</span><span class="p">:</span><span class="mi">22</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">version</span><span class="p">:</span><span class="mi">4</span><span class="o">&gt;</span> <span class="o">|</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">version</span></code> making up the lowest 4 bits. The id is stored as bytes, and sorted on string ordering, i.e. the high qword (token) is msb in ordering.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">index</span></code> bits indicate the vnode index the id belongs to, i.e. the vnode owning the end of the token range in which the id sits.</p>
<p>The random bits exist to help ensure ids are sufficiently unique across
generations.</p>
</div>
<div class="section" id="generations">
<h2>Generations<a class="headerlink" href="#generations" title="Permalink to this headline">¶</a></h2>
<p>A <strong>CDC generation</strong> is a structure consisting of:</p>
<ol class="simple">
<li><p>a <strong>generation timestamp</strong>, describing the time point from which this generation “starts operating” (more on that later),</p></li>
<li><p>a set of stream IDs,</p></li>
<li><p>a mapping from the set of tokens (in the entire token ring) to the set of stream IDs in this generation.</p></li>
</ol>
<p>The mapping from point 3 has a simple structure, allowing us to compactly store a CDC generation. This is the purpose of the <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">cdc</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">token_range_description</span> <span class="p">{</span>
        <span class="n">dht</span><span class="p">::</span><span class="n">token</span> <span class="n">token_range_end</span><span class="p">;</span>
        <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">stream_id</span><span class="o">&gt;</span> <span class="n">streams</span><span class="p">;</span>
        <span class="n">uint8_t</span> <span class="n">sharding_ignore_msb</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">topology_description</span> <span class="p">{</span>
        <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">token_range_description</span><span class="o">&gt;</span> <span class="n">_entries</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
        <span class="o">...</span> <span class="n">methods</span> <span class="o">...</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>From a <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> we can read the set of stream IDs of this generation and the mapping. How <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> represents the mapping is explained later.</p>
<p>Each node in a Scylla cluster stores a set of CDC generations using the <code class="docutils literal notranslate"><span class="pre">cdc::metadata</span></code> class. Simplified definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">cdc</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">metadata</span> <span class="n">final</span> <span class="p">{</span>
        <span class="n">using</span> <span class="n">container_t</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">map</span><span class="o">&lt;</span><span class="n">api</span><span class="p">::</span><span class="n">timestamp_type</span><span class="p">,</span> <span class="n">topology_description</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">container_t</span> <span class="n">_gens</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">_gens</span></code> map’s key is the generation’s timestamp.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">container_t::iterator</span> <span class="pre">it</span></code> point to some generation in this set. We say that the generation given by <code class="docutils literal notranslate"><span class="pre">*it</span></code> <strong>operates</strong> in a time interval <code class="docutils literal notranslate"><span class="pre">[T,</span> <span class="pre">T')</span></code> (where T, T’ are timestamps) if and only if:</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> is the generation’s timestamp (<code class="docutils literal notranslate"><span class="pre">it-&gt;first</span></code>),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T'</span></code> is the following generation’s timestamp (<code class="docutils literal notranslate"><span class="pre">std::next(it)-&gt;first</span></code>).</p></li>
</ol>
<p>This set changes while the node runs. If there is no following generation (<code class="docutils literal notranslate"><span class="pre">std::next(it)</span> <span class="pre">==</span> <span class="pre">std::end(_gens)</span></code>), it simply means that this node doesn’t yet know what that following generation will be. It might happen that <code class="docutils literal notranslate"><span class="pre">T'</span> <span class="pre">=</span> <span class="pre">∞</span></code> (i.e. there really won’t ever be a following generation) but that’s unlikely.</p>
<p>When a write is performed to a base table, the write is translated to a mutation, which holds a timestamp. This timestamp together with the token of the write’s partition key is used to retrieve the stream ID which will then be used to create a corresponding log table write. The stream ID is taken from the generation operating at this timestamp using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">cdc</span><span class="p">::</span><span class="n">stream_id</span> <span class="n">cdc</span><span class="p">::</span><span class="n">metadata</span><span class="p">::</span><span class="n">get_stream</span><span class="p">(</span><span class="n">api</span><span class="p">::</span><span class="n">timestamp_type</span> <span class="n">ts</span><span class="p">,</span> <span class="n">dht</span><span class="p">::</span><span class="n">token</span> <span class="n">tok</span><span class="p">,</span> <span class="n">const</span> <span class="n">dht</span><span class="p">::</span><span class="n">i_partitioner</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here’s a simplified snippet of code illustrating how the log write’s mutation is created (from cdc/log.cc; <code class="docutils literal notranslate"><span class="pre">m</span></code> is the base table mutation):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">mutation</span> <span class="n">transform</span><span class="p">(</span><span class="n">const</span> <span class="n">mutation</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
        <span class="n">auto</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">find_timestamp</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="n">auto</span> <span class="n">stream_id</span> <span class="o">=</span> <span class="n">_ctx</span><span class="o">.</span><span class="n">_cdc_metadata</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">token</span><span class="p">(),</span> <span class="n">_ctx</span><span class="o">.</span><span class="n">_partitioner</span><span class="p">);</span>
        <span class="n">mutation</span> <span class="n">res</span><span class="p">(</span><span class="n">_log_schema</span><span class="p">,</span> <span class="n">stream_id</span><span class="o">.</span><span class="n">to_partition_key</span><span class="p">(</span><span class="o">*</span><span class="n">_log_schema</span><span class="p">));</span>

        <span class="o">...</span> <span class="n">fill</span> <span class="s2">&quot;res&quot;</span> <span class="k">with</span> <span class="n">the</span> <span class="n">log</span> <span class="n">write</span><span class="s1">&#39;s column data ...</span>

    <span class="p">}</span>
</pre></div>
</div>
<div class="section" id="the-generation-s-mapping">
<h3>The generation’s mapping<a class="headerlink" href="#the-generation-s-mapping" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> class contains a vector of <code class="docutils literal notranslate"><span class="pre">token_range_description</span></code> entries, sorted by <code class="docutils literal notranslate"><span class="pre">token_range_end</span></code>. These entries split the token ring into ranges: for each <code class="docutils literal notranslate"><span class="pre">i</span></code> in <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">_entries.size()</span> <span class="pre">-</span> <span class="pre">1</span></code> we get the range (<code class="docutils literal notranslate"><span class="pre">_entries[i].token_range_end</span></code>, <code class="docutils literal notranslate"><span class="pre">_entries[(i+1)</span> <span class="pre">%</span> <span class="pre">_entries.size()]</span></code>] (the range is left-opened, right-closed).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">i</span></code>th entry defines how tokens in the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range (the one ending with <code class="docutils literal notranslate"><span class="pre">_entries[i].token_range_end</span></code>) are mapped to the vector of streams given by <code class="docutils literal notranslate"><span class="pre">_entries[i].streams</span></code> as follows. Suppose that the used partitioner is given by <code class="docutils literal notranslate"><span class="pre">p</span></code> (of type <code class="docutils literal notranslate"><span class="pre">i_partitioner&amp;</span></code>). Suppose <code class="docutils literal notranslate"><span class="pre">tok</span></code> (of type <code class="docutils literal notranslate"><span class="pre">dht::token</span></code>) falls into the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range.
Then <code class="docutils literal notranslate"><span class="pre">tok</span></code> is mapped into</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">shard_of</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">streams</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sharding_ignore_msb</span><span class="p">)]</span>
</pre></div>
</div>
<p>The motivation for this is the following: the token ranges defined by <code class="docutils literal notranslate"><span class="pre">topology_description</span></code> using <code class="docutils literal notranslate"><span class="pre">token_range_end</span></code>s are a refinement of vnodes in the token ring at the time when this generation operates (i.e. each range defined by this generation is wholly contained in a single vnode). The streams in vector <code class="docutils literal notranslate"><span class="pre">_entries[i].streams</span></code> have their tokens in the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range. Therefore we map each token <code class="docutils literal notranslate"><span class="pre">tok</span></code> to a stream whose token falls into the the same vnode as <code class="docutils literal notranslate"><span class="pre">tok</span></code>. Hence, when we perform a base table write, the corresponding CDC log write will fall into the same vnode, thus it will have the same set of replicas as the base write. We call this property <strong>colocation</strong> of base and log writes.</p>
<p>To achieve the above it would be enough if <code class="docutils literal notranslate"><span class="pre">_entries[i].streams</span></code> was a single stream, not a vector of streams. But we went further and aim to achieve not only colocation of replicas, but also colocation of shards (not necessarily at all replicas, but a subset of them at least).</p>
<p>Suppose that some node <code class="docutils literal notranslate"><span class="pre">A</span></code> is a replica for the vnode containing the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range. Suppose that the number of shards of <code class="docutils literal notranslate"><span class="pre">A</span></code> is <code class="docutils literal notranslate"><span class="pre">_entries[i].streams.size()</span></code>, and the value of <code class="docutils literal notranslate"><span class="pre">sharding_ignore_msb</span></code> parameter used by the configured partitioner is <code class="docutils literal notranslate"><span class="pre">_entries[i].sharding_ignore_msb</span></code>. Suppose that we chose <code class="docutils literal notranslate"><span class="pre">_entries[i].streams[j]</span></code> so that its token is owned by the <code class="docutils literal notranslate"><span class="pre">j</span></code>th shard on node <code class="docutils literal notranslate"><span class="pre">A</span></code>.
Then base table writes with tokens that fall into the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range and into the <code class="docutils literal notranslate"><span class="pre">j</span></code>th shard on node <code class="docutils literal notranslate"><span class="pre">A</span></code> will have their corresponding log table entries also written to the <code class="docutils literal notranslate"><span class="pre">j</span></code>th shard, at least on node <code class="docutils literal notranslate"><span class="pre">A</span></code>. If all nodes use the same number of shards (which is pretty common), we’ll get shard-colocation on every replica.</p>
<p>Vnode-colocation is important for consistency: when the base write goes to the same set of replicas as the log write, it is possible to make sure that each replica either receives both writes or none of them. Thus the CDC log will be able to truly reflect what happened in the base table.
Shard-colocation is an optimization.</p>
</div>
</div>
<div class="section" id="generation-switching">
<h2>Generation switching<a class="headerlink" href="#generation-switching" title="Permalink to this headline">¶</a></h2>
<p>Having different generations operating at different points in time is necessary to maintain colocation in presence of topology changes. When a new node joins the cluster it modifies the token ring by refining existing vnodes into smaller vnodes. But before it does it, it will introduce a new CDC generation whose token ranges refine those new (smaller) vnodes (which means they also refine the old vnodes; that way writes will be colocated on both old and new replicas).</p>
<p>The joining node learns about the current vnodes, chooses tokens which will split them into smaller vnodes and creates a new <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> which refines those smaller vnodes. This is done in the <code class="docutils literal notranslate"><span class="pre">cdc::generate_topology_description</span></code> function. It then inserts the generation description into an internal distributed table <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> in the <code class="docutils literal notranslate"><span class="pre">system_distributed</span></code> keyspace. The table is defined as follows (from db/system_distributed_keyspace.cc):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        return schema_builder(system_distributed_keyspace::NAME, system_distributed_keyspace::CDC_TOPOLOGY_DESCRIPTION, {id})
                /* The timestamp of this CDC generation. */
                .with_column(&quot;time&quot;, timestamp_type, column_kind::partition_key)
                /* The description of this CDC generation (see `cdc::topology_description`). */
                .with_column(&quot;description&quot;, cdc_generation_description_type)
                /* Expiration time of this CDC generation (or null if not expired). */
                .with_column(&quot;expired&quot;, timestamp_type)
                .with_version(system_keyspace::generate_schema_version(id))
                .build();
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_stream_tuple_type</span> <span class="o">=</span> <span class="n">tuple_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">({</span><span class="n">long_type</span><span class="p">,</span> <span class="n">long_type</span><span class="p">});</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_streams_list_type</span> <span class="o">=</span> <span class="n">list_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span><span class="n">cdc_stream_tuple_type</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_token_range_description_type</span> <span class="o">=</span> <span class="n">tuple_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span>
        <span class="p">{</span> <span class="n">utf8_type</span>             <span class="o">//</span> <span class="n">dht</span><span class="p">::</span><span class="n">token</span> <span class="n">token_range_end</span><span class="p">;</span>
        <span class="p">,</span> <span class="n">cdc_streams_list_type</span> <span class="o">//</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">stream_id</span><span class="o">&gt;</span> <span class="n">streams</span><span class="p">;</span>
        <span class="p">,</span> <span class="n">byte_type</span>             <span class="o">//</span> <span class="n">uint8_t</span> <span class="n">sharding_ignore_msb</span><span class="p">;</span>
        <span class="p">});</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_generation_description_type</span> <span class="o">=</span> <span class="n">list_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span><span class="n">cdc_token_range_description_type</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
</pre></div>
</div>
<p>The timestamp for the new generation is chosen by taking the node’s local time and adding a minute or two so that other nodes have a chance to learn about this generation before it starts operating. Thus, the node makes the following assumptions:</p>
<ol class="simple">
<li><p>its clock is not too desynchronized with other nodes’ clocks,</p></li>
<li><p>the cluster is not partitioned.</p></li>
</ol>
<p>Future patches will make the solution safe by using a two-phase-commit approach.</p>
<p>Next, the node starts gossiping the timestamp of the new generation together with its set of chosen tokens and status:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="n">_gossiper</span><span class="o">.</span><span class="n">add_local_application_state</span><span class="p">({</span>
            <span class="p">{</span> <span class="n">gms</span><span class="p">::</span><span class="n">application_state</span><span class="p">::</span><span class="n">TOKENS</span><span class="p">,</span> <span class="n">versioned_value</span><span class="p">::</span><span class="n">tokens</span><span class="p">(</span><span class="n">_bootstrap_tokens</span><span class="p">)</span> <span class="p">},</span>
            <span class="p">{</span> <span class="n">gms</span><span class="p">::</span><span class="n">application_state</span><span class="p">::</span><span class="n">CDC_STREAMS_TIMESTAMP</span><span class="p">,</span> <span class="n">versioned_value</span><span class="p">::</span><span class="n">cdc_streams_timestamp</span><span class="p">(</span><span class="n">_cdc_streams_ts</span><span class="p">)</span> <span class="p">},</span>
            <span class="p">{</span> <span class="n">gms</span><span class="p">::</span><span class="n">application_state</span><span class="p">::</span><span class="n">STATUS</span><span class="p">,</span> <span class="n">versioned_value</span><span class="p">::</span><span class="n">bootstrapping</span><span class="p">(</span><span class="n">_bootstrap_tokens</span><span class="p">)</span> <span class="p">},</span>
        <span class="p">})</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
<p>When other nodes learn about the generation, they’ll extract it from the <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> table and save it using <code class="docutils literal notranslate"><span class="pre">cdc::metadata::insert(db_clock::time_point,</span> <span class="pre">topology_description&amp;&amp;)</span></code>.
Notice that nodes learn about the generation together with the new node’s tokens. When they learn about its tokens they’ll immediately start sending writes to the new node (in the case of bootstrapping, it will become a pending replica). But the old generation will still be operating for a minute or two. Thus colocation will be lost for a while. This problem will be fixed when the two-phase-commit approach is implemented.</p>
<p>We’re not able to prevent a node learning about a new generation too late due to a network partition: if gossip doesn’t reach the node in time, some writes might be sent to the wrong (old) generation.
However, it could happen that a node learns about the generation from gossip in time, but then won’t be able to extract it from <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code>. In that case we can still maintain consistency: the node will remember that there is a new generation even though it doesn’t yet know what it is (just the timestamp) using the <code class="docutils literal notranslate"><span class="pre">cdc::metadata::prepare(db_clock::time_point)</span></code> method, and then <em>reject</em> writes for CDC-enabled tables that are supposed to use this new generation. The node will keep trying to read the generation’s data in background until it succeeds or sees that it’s not necessary anymore (e.g. because the generation was already superseded by a new generation).
Thus we give up availability for safety. This likely won’t happen if the administrator ensures that the cluster is not partitioned before bootstrapping a new node. This problem will also be mitigated with a future patch.</p>
<p>Due to the need of maintaining colocation we don’t allow the client to send writes with arbitrary timestamps.
Suppose that a write is requested and the write coordinator’s local clock has time <code class="docutils literal notranslate"><span class="pre">C</span></code> and the generation operating at time <code class="docutils literal notranslate"><span class="pre">C</span></code> has timestamp <code class="docutils literal notranslate"><span class="pre">T</span></code> (<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">&lt;=</span> <span class="pre">C</span></code>). Then we only allow the write if its timestamp is in the interval [<code class="docutils literal notranslate"><span class="pre">T</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">+</span> <span class="pre">generation_leeway</span></code>), where <code class="docutils literal notranslate"><span class="pre">generation_leeway</span></code> is a small time-inteval constant (e.g. 5 seconds).
Reason: we cannot allow writes before <code class="docutils literal notranslate"><span class="pre">T</span></code>, because they belong to the old generation whose token ranges might no longer refine the current vnodes, so the corresponding log write would not necessarily be colocated with the base write. We also cannot allow writes too far “into the future” because we don’t know what generation will be operating at that time (the node which will introduce this generation might not have joined yet). But, as mentioned before, we assume that we’ll learn about the next generation in time. Again — the need for this assumption will be gone in a future patch.</p>
</div>
<div class="section" id="streams-description-table">
<h2>Streams description table<a class="headerlink" href="#streams-description-table" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cdc_streams_descriptions</span></code> table in the <code class="docutils literal notranslate"><span class="pre">system_distributed</span></code> keyspace allows CDC clients to learn about available sets of streams and the time intervals they are operating at. It’s definition is as follows (db/system_distributed_keyspace.cc):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="k">return</span> <span class="n">schema_builder</span><span class="p">(</span><span class="n">system_distributed_keyspace</span><span class="p">::</span><span class="n">NAME</span><span class="p">,</span> <span class="n">system_distributed_keyspace</span><span class="p">::</span><span class="n">CDC_DESC</span><span class="p">,</span> <span class="p">{</span><span class="nb">id</span><span class="p">})</span>
                <span class="o">/*</span> <span class="n">The</span> <span class="n">timestamp</span> <span class="n">of</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">timestamp_type</span><span class="p">,</span> <span class="n">column_kind</span><span class="p">::</span><span class="n">partition_key</span><span class="p">)</span>
                <span class="o">/*</span> <span class="n">The</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">stream</span> <span class="n">identifiers</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;streams&quot;</span><span class="p">,</span> <span class="n">cdc_streams_set_type</span><span class="p">)</span>
                <span class="o">/*</span> <span class="n">Expiration</span> <span class="n">time</span> <span class="n">of</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span> <span class="p">(</span><span class="ow">or</span> <span class="n">null</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">expired</span><span class="p">)</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;expired&quot;</span><span class="p">,</span> <span class="n">timestamp_type</span><span class="p">)</span>
                <span class="o">.</span><span class="n">with_version</span><span class="p">(</span><span class="n">system_keyspace</span><span class="p">::</span><span class="n">generate_schema_version</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
                <span class="o">.</span><span class="n">build</span><span class="p">();</span>
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_stream_tuple_type</span> <span class="o">=</span> <span class="n">tuple_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">({</span><span class="n">long_type</span><span class="p">,</span> <span class="n">long_type</span><span class="p">});</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_streams_set_type</span> <span class="o">=</span> <span class="n">set_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span><span class="n">cdc_stream_tuple_type</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
</pre></div>
</div>
<p>This table simply contains each generation’s timestamp (as partition key) and the set of stream IDs used by this generation. It is meant to be user-facing, in contrast to <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> which is used internally.</p>
<p>When nodes learn about a CDC generation through gossip, they race to update the description table by inserting a proper row (see <code class="docutils literal notranslate"><span class="pre">cdc::update_streams_description</span></code>). This operation is idempotent so it doesn’t matter if multiple nodes do it at the same time.</p>
<div class="section" id="todo-expired-generations">
<h3>TODO: expired generations<a class="headerlink" href="#todo-expired-generations" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">expired</span></code> column in <code class="docutils literal notranslate"><span class="pre">cdc_streams_descriptions</span></code> and <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> means that this generation was superseded by some new generation and will soon be removed (its table entry will be gone). This functionality is yet to be implemented.</p>
</div>
</div>
</div>

        </div>

        <div id="sidebar" class="large-3 large-pull-6 columns"><div class="side-nav">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Scylla Developer Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alternator/alternator.html">Alternator: DynamoDB API in Scylla</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IDL.html">IDL definition</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">CDC</a></li>
<li class="toctree-l2"><a class="reference internal" href="compaction_controller.html">The Compaction Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="cql-extensions.html">Scylla CQL extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="cql3-type-mapping.html">CQL3 Type Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="hinted_handoff_design.html">Hinted Handoff Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="in_memory_representation.html">In-Memory Representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="isolation.html">Performance Isolation in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="lua-type-mapping.html">CQL to Lua type mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="metrics.html">Scylla Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="migrating-from-users-to-roles.html">Migrating from users to roles</a></li>
<li class="toctree-l2"><a class="reference internal" href="paged-queries.html">Paged queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocol-extensions.html">Protocol extensions to the Cassandra Native Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Ports and protocols in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="redis.html">Redis API in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="repair_based_node_ops.html">Repair based node operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="row_cache.html">Row Cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="row_level_repair.html">Row level repair</a></li>
<li class="toctree-l2"><a class="reference internal" href="secondary_index.html">Secondary indexes in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="sstable-scylla-format.html">File format of the Scylla.db sstable component</a></li>
<li class="toctree-l2"><a class="reference internal" href="sstables-directory-structure.html">sstables directory structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="system_keyspace.html">System keyspace layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="system_schema_keyspace.html">System schema keyspace layout</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contribute</a></li>
</ul>

</div>
        </div>

        <div class="large-3 columns">
            
        </div>

    </div>
</section>

<!-- newsleter modal -->

<div id="newsletter_signup" class="reveal-modal tiny radius dark_modal" data-reveal aria-labelledby="modalTitle" aria-hidden="true" role="dialog">
    <a class="close-reveal-modal" aria-label="Close">×</a>
    <h2 id="modalTitle">Sign up for the Scylla newsletter</h2>
    <div id="mc_embed_signup">
        <form action="//cloudius-systems.us10.list-manage.com/subscribe/post?u=df8bb543c68230d5f7b4dcf78&amp;id=9a4589f144" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
            <div id="mc_embed_signup_scroll">

                <div class="mc-field-group">
                    <div class="row collapse">
                        <div class="small-3 columns"><label for="mce-EMAIL">Email</label></div>
                        <div class="small-9 columns"><input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL"></div>
                    </div>
                </div>
                <div class="mc-field-group">
                    <div class="row collapse">
                        <div class="small-3 columns"><label for="mce-FNAME">First Name </label></div>
                        <div class="small-9 columns"><input type="text" value="" name="FNAME" class="" id="mce-FNAME"></div>
                    </div>
                </div>
                <div class="mc-field-group">
                    <div class="row collapse">
                        <div class="small-3 columns"><label for="mce-LNAME">Last Name </label></div>
                        <div class="small-9 columns"><input type="text" value="" name="LNAME" class="" id="mce-LNAME"></div>
                    </div>
                </div>
                <div id="mce-responses" class="clear">
                    <div class="response" id="mce-error-response" style="display:none"></div>
                    <div class="response" id="mce-success-response" style="display:none"></div>
                </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
                <div style="position: absolute; left: -5000px;"><input type="text" name="b_df8bb543c68230d5f7b4dcf78_9a4589f144" tabindex="-1" value=""></div>
                <div class="clear"><input type="submit" class="button" value="Sign up" name="subscribe" id="mc-embedded-subscribe"></div>
            </div>
        </form>
    </div>
</div>

<!-- end newsleter modal -->



<!-- footer.html -->
<footer id="footer">
    <div class="footer-top">
        <a class="logo" href="https://www.scylladb.com"><img src="../_static/img/logo-scylla-horizontal-RGB.svg" alt=""></a>
        <div class="footer-links">
            <a class="link" href="https://docs.scylladb.com">Docs</a>
            <a class="link" href="https://www.scylladb.com/company/contact-us/">Contact Us</a>
            <a class="link" href="https://www.scylladb.com/company/">About Us</a>
            <a class="link button" href="https://github.com/scylladb/scylla/issues/new?title=Issue in page CDC&&body=I%20would%20like%20to%20report%20an%20issue%20in%20page%20https://scylladb.github.io/scylla/master/design-notes/cdc%0A%0A%23%23%23%20Problem%0A%0A%23%23%23%20%20Suggest%20a%20fix" target="_blank">
                Report an issue on this page</a>
        </div>
        <div class="footer-actions">
            <a class="link-icon" href="https://github.com/ScyllaDB" target="_blank">
                <span class="icon-github2"></span></a>
            <a class="link-icon" href="https://twitter.com/ScyllaDB" target="_blank">
                <span class="icon-twitter"></span></a>
            <a class="link-icon" href="https://www.linkedin.com/company/scylladb"  target="_blank">
                <span class="icon-linkedin2"></span></a>
            <a class="link-icon" href="https://www.facebook.com/scylladb/" target="_blank">
                <span class="icon-facebook"></span></a>
        </div>
    </div>

    <div class="footer-bottom">
        <div class="footer-info">
            <div class="footer-copyright">
                &#169; 2021, ScyllaDB. All rights reserved.
            </div>
            <div class="footer-last-updated">
                Last updated on 04 January 2021.
            </div>
        </div>
        <div class="footer-links">
        </div>
    </div>
</footer>
<!-- end footer.html -->

<!-- bodyscripts.html -->
<!-- at the end of the BODY --> 
<script src="../_static/js/vendor/jquery.js"></script>
<script src="../_static/js/vendor/jquery.cookie.min.js"></script>
<script src="../_static/expertrec.js"></script>
<script src="../_static/js/foundation/foundation.js"></script>
<script src="../_static/js/foundation/foundation.topbar.js"></script>
<script src="../_static/app.js"></script>
<script>
    $(document).foundation();
</script>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T8P2JP"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

  <!-- end bodyscripts.html -->
</body>
</html>